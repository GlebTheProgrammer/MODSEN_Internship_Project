# Постановка задача
Разработать CRUD Web API для работы с мероприятиями (создание, изменение, удаление, получение), проект должен выполняться на .Net Core, с использованием EF Core.

### Функционал Web API
1. Получение списка всех событий;
2. Получение определённого события по его Id;
3. Регистрация нового события;
4. Изменение информации о существующем событии;
5. Удаление события.

### Информация о событии
1. Название / тема;
2. Описание, план;
3. Организатор, спикер;
4. Время и место проведения.

### Используемые в проекте технологии
1. .Net 5.0+;
2. Entity Framework Core;
3. MS SQL / PostgreSQL or any other;
4. AutoMapper / Mapster or any other;
5. Authentication via bearer token (ex.: IdentityServer4);
6. Swagger.

# Документация к проекту (Pуководство)

>Программа запускается через Swagger UI.

>Для грамотного тестирования, а также для тестирования другими пользователями, в проект была добавлена своего рода заглушка - `MockMeetupRepository`, которая предоставит возможность тестировать API пользователям, не имея доступа к моей локальной БД.
>Для взаимодействия с локальной БД, был создан отдельный класс - `SqlMeetupRepository`, который предоставляет возможность работать с базой данных на локальном ПК
>>p.s. Для работы с тем или иным репозиторием, один из них нужно закомментировать в `Program.cs`

>Перед тем, как использовать `Endpoints` приложения, необходимо сначала получить `Token` через метод `GET` контроллера `TokenProvider`, после чего скопировать полученный токен, и вставить его в соответствующее поле (Появится после нажатия кнопки `Authorize`, расположенной вверху приложения) в формате `"Bearer abcdefg"`, где `abcdefg` - сгенерированный программой токен. После этого, клиент может спокойно пользоваться всем функционалом приложения.

>В программе были реализованы такие `Endpoints`, как:


| URI | Метод | Операция | Описание | Успешное выполнение | Ошибка
|:----------------:|:---------:|:----------------:|:----------------:|:---------:|:----------------:|
| api/events | GET | READ | Чтение всех событий | 200 ОК | 404 Bad Request / 404 Not Found |
| api/events/{id} | GET | READ | Чтение единичного события по id | 200 ОК | 404 Bad Request / 404 Not Found |
| api/events | POST | CREATE | Создание нового события | 201 Created | 404 Bad Request / 404 Not Found |
| api/events/{id} | PUT | UPDATE | Обновление всего объекта события | 204 No Content | 404 Bad Request / 404 Not Found |
| api/events/{id} | PATCH | UPDATE | Обновление какой-то части объекта события | 204 No Content | 404 Bad Request / 404 Not Found |
| api/events/{id} | DELETE | DELETE | Удаление события по id | 200 ОК \ 204 No Content | 404 Bad Request / 404 Not Found |

## Архитектура

Архитектура была построена таким образом, чтоб можно было разграничить предметные области, а также сделать так, чтоб компоненты имели слабую связь по отношению друг к другу.

Клиент, желая получить информацию, посылает `HTTP Request` к `EventController.cs`, котрый в свою очередь взаимодействует одним из `SqlMeetupRepository.cs` или `MockMeetupRepository.cs`. В случае использования `SqlMeetupRepository.cs`, появляется `MeetupDbContext.cs`, который выполняет роль промежуточного слоя, через который приложение взаимодействует с БД, по факту, предоставляе доступ к данным БД, в моём случае `MS SQL Server-а`. Как только поступает тот или иной запрос, в ход вступает `AutoMapper`, функции которого в моём проетке выполняет `EventsProfile.cs`. В нём чётко расписаны правила, по которым один объект может быть реконструирован в другой (Роль этих объектов выполняют `DTOs`, или `Data Transfer Objects`, в моей программе представленные как `EventReadDto.cs`, `EventCreateDto.cs` и `EventUpdateDto.cs`, в которых описаны те поля, которые должны быть доступны на том или ином уровне, будь то добавление события, обновление или чтение). При формировании ответа сервером, происходит отправка `HTTP Response` в формате `JSON`.
